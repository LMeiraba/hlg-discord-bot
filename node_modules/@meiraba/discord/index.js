const axios = require("axios")
const qs = require('querystring')
const events = require("events")
const WebSocket = require("ws")
const nacl = require('tweetnacl');
const { opCode, properties, intents, opCode_voice } = require("./utils/Constants.js");
const IntentsCalculator = require("./utils/IntentsCalculator.js");
class Bot {
    constructor({ token }) {
        this.token = token
        this.user = new (require("./src/user.js"))({ token: this.token })
        this.command = new (require("./src/command.js"))({ token: this.token })
        this.channel = new (require("./src/channel.js"))({ token: this.token })
    }
}
class Interaction {
    endpoint = class {
        constructor({ public_key }) {
            this.public_key = public_key
        }
        async verify({signature,timestamp,body}) {
            const isVerified = await nacl.sign.detached.verify(
                Buffer.from(timestamp + body),
                Buffer.from(signature, 'hex'),
                Buffer.from(this.public_key, 'hex')
            );
            if (!isVerified) {
                return {
                  statusCode: 401,
                  message: 'invalid request signature',
                };
            } else {
                return {
                  statusCode: 200,
                  message: JSON.stringify({type: 1}),
                };
            }
            // let v = await endpoint.verify({
            //     signature: req.get('X-Signature-Ed25519'),
            //     timestamp: req.get('x-signature-timestamp'),
            //     body: JSON.stringify(req.body)
            //   })
            //   res.header('content-type', 'text/plain')
            //   res.status(v.statusCode).end(v.message)
        }
    }
    callback = require("./src/callback.js")
    followup = require("./src/followup.js")
}
class Client {
    constructor({ token }) {
        let ev = new events.EventEmitter()
        this.on = ev.on;
        this.emit = ev.emit;
        this.token = token;
        this.user = null
    }
    start(Intents) {
        (function keepalive() {
            setTimeout(keepalive, 0x7FFFFFFF);
        })();
        const ws = new WebSocket("wss://gateway.discord.gg/?v=9&encoding=json");
        const myIntents = IntentsCalculator.Calculate(Intents ? Intents.map(i => intents[i]) : Object.values(intents));
        const Token = this.token
        const THIS = this
        THIS.on("update_status", (data) => {
            ws.send(JSON.stringify({ op: opCode.PRESENCE_UPDATE, d: data }))
        })
        THIS.on("join_voice", (data) => {
            ws.send(JSON.stringify({ op: opCode.VOICE_STATE_UPDATE, d: data }))
        })
        ws.on('message', function incoming(data) {
            let payload = JSON.parse(data);
            const { d, t: event, op } = payload;
            switch (op) {
                case opCode.HELLO:
                    heartbeat(d.heartbeat_interval);
                    identify(Token);
                    break;
                case opCode.RECONNECT:
                    reconnect(Token);
                    break;
                case opCode.INVALID_SESSION:
                    throw "Connection to discord failed." + JSON.stringify(payload)
                    break;
            }
            if (event === 'READY') THIS.user = d.user
            THIS.emit(event, d)
        })

        function identify(token_) {
            ws.send(JSON.stringify({ op: opCode.IDENTIFY, d: { token: token_, intents: myIntents, properties } }))
        }
        async function reconnect(botToken) {
            setInterval(() => {
                identify(botToken);
            }, 3000)
        }
        function heartbeat(interval) {
            setInterval(() => {
                ws.send(JSON.stringify({ op: opCode.HEARTBEAT, d: null }))
            }, interval)
        }
    }
    status(params) {
        if (this.user) {
            params.since = new Date().getTime(),
                params.afk = false
            this.emit("update_status", params)
        } else throw "Not logged in, first call .start()"
    }
    async voice(params) {
        if (this.user) {
            (function keepalive() {
                setTimeout(keepalive, 0x7FFFFFFF);
            })();
            const Token = this.token
            const THIS = this
            let session_id, server
            THIS.emit("join_voice", params)


            THIS.on("VOICE_STATE_UPDATE", (state_info) => {
                if (state_info.user_id === THIS.user.id) session_id = state_info.session_id ?? session_id
            })
            THIS.on("VOICE_SERVER_UPDATE", (server_info) => {
                server = server_info
            })
            while (!session_id || !server) { await sleep(300) }

            const ws = new WebSocket(`wss://${server.endpoint}?v=7`)

            ws.on("message", (data) => {
                data = JSON.parse(data)
                const { d, op } = data
                console.log(data)
                if (op === opCode_voice.HELLO) {
                    heartbeat(d.heartbeat_interval);
                    ws.send(JSON.stringify({
                        op: opCode_voice.IDENTIFY, d: {
                            server_id: server.guild_id,
                            user_id: THIS.user.id,
                            session_id: session_id,
                            token: server.token
                        }
                    }))
                }
                if (op === opCode_voice.READY) {
                    ws.send(JSON.stringify({
                        op: opCode_voice.SELECT_PROTOCOL,
                        d: {
                            protocol: "udp",
                            data: {
                                address: d.ip,
                                port: d.port,
                                mode: 'xsalsa20_poly1305_lite'
                            }
                        }
                    }))
                    ws.send(JSON.stringify({
                        "op": 5,
                        "d": {
                            "speaking": 1 << 0,
                            "delay": 0,
                            "ssrc": server.ssrc
                        }
                    }))
                }
            })

            async function sleep(ms) {
                return new Promise((resolve) => {
                    setTimeout(resolve, ms);
                });
            };
            function heartbeat(interval) {
                setInterval(() => {
                    ws.send(JSON.stringify({ op: opCode_voice.HEARTBEAT, d: null }))
                }, interval)
            }
        } else throw "Not logged in, first call .start()"
    }
}

module.exports = {
    Bot,
    OAuth: require("./src/Oauth.js"),
    Client,
    Interaction
}
